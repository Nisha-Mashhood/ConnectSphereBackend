{"version":3,"file":"review-repository.js","sourceRoot":"","sources":["../../src/Repositories/review-repository.ts"],"names":[],"mappings":"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","sourcesContent":["import { injectable } from 'inversify';\r\nimport { Model, PipelineStage, Types } from 'mongoose';\r\nimport { BaseRepository } from '../core/repositries/base-repositry';\r\nimport { RepositoryError } from '../core/utils/error-handler';\r\nimport logger from '../core/utils/logger';\r\nimport Review from '../Models/review-model';\r\nimport { IReview } from '../Interfaces/Models/i-review';\r\nimport { StatusCodes } from '../enums/status-code-enums';\r\nimport { IReviewRepository } from '../Interfaces/Repository/i-review-repositry';\r\n\r\n@injectable()\r\nexport class ReviewRepository extends BaseRepository<IReview> implements IReviewRepository {\r\n  constructor() {\r\n    super(Review as Model<IReview>);\r\n  }\r\n\r\n  private toObjectId = (id?: string | Types.ObjectId): Types.ObjectId => {\r\n    if (!id) {\r\n      logger.warn('Missing ID when converting to ObjectId');\r\n      throw new RepositoryError('Invalid ID: ID is required', StatusCodes.BAD_REQUEST);\r\n    }\r\n    const idStr = typeof id === 'string' ? id : id.toString();\r\n    if (!Types.ObjectId.isValid(idStr)) {\r\n      logger.warn(`Invalid ObjectId format: ${idStr}`);\r\n      throw new RepositoryError('Invalid ID: must be a 24 character hex string', StatusCodes.BAD_REQUEST);\r\n    }\r\n    return new Types.ObjectId(idStr);\r\n  }\r\n\r\n  public createReview = async (data: { userId: string; rating: number; comment: string }): Promise<IReview> => {\r\n    try {\r\n      logger.debug(`Creating review for user: ${data.userId}`);\r\n      const review = await this.create({\r\n        userId: this.toObjectId(data.userId),\r\n        rating: data.rating,\r\n        comment: data.comment,\r\n        isApproved: false,\r\n        isSelect: false,\r\n        createdAt: new Date(),\r\n      });\r\n      logger.info(`Review created: ${review._id}`);\r\n      return review;\r\n    } catch (error: unknown) {\r\n      const err = error instanceof Error ? error : new Error(String(error));\r\n      logger.error(`Error creating review for user ${data.userId}`, err);\r\n      throw new RepositoryError('Error creating review', StatusCodes.INTERNAL_SERVER_ERROR, err);\r\n    }\r\n  }\r\n\r\n  public findReviewById = async (reviewId: string): Promise<IReview | null> => {\r\n    try {\r\n      logger.debug(`Fetching review by ID: ${reviewId}`);\r\n      const review = await this.model\r\n        .findById(this.toObjectId(reviewId))\r\n        .populate('userId', '_id email name')\r\n        .exec();\r\n      if (!review) {\r\n        logger.warn(`Review not found: ${reviewId}`);\r\n        throw new RepositoryError(`Review not found with ID: ${reviewId}`, StatusCodes.NOT_FOUND);\r\n      }\r\n      logger.info(`Review found: ${reviewId}`);\r\n      return review;\r\n    } catch (error: unknown) {\r\n      const err = error instanceof Error ? error : new Error(String(error));\r\n      logger.error(`Error fetching review by ID ${reviewId}`, err);\r\n      throw new RepositoryError('Error fetching review by ID', StatusCodes.INTERNAL_SERVER_ERROR, err);\r\n    }\r\n  }\r\n\r\n public async getAllReviews({\r\n  page = 1,\r\n  limit = 10,\r\n  search = \"\",\r\n}: {\r\n  page?: number;\r\n  limit?: number;\r\n  search?: string;\r\n}): Promise<{ reviews: IReview[]; total: number; page: number; pages: number }> {\r\n  try {\r\n    logger.debug(\r\n      `Fetching reviews paginated (page=${page}, limit=${limit}, search=${search})`\r\n    );\r\n\r\n    const matchStage =\r\n      search.trim() !== \"\"\r\n        ? {\r\n            $or: [\r\n              { comment: { $regex: search, $options: \"i\" } },\r\n              { \"userId.name\": { $regex: search, $options: \"i\" } },\r\n              { \"userId.email\": { $regex: search, $options: \"i\" } },\r\n            ],\r\n          }\r\n        : {};\r\n\r\n    const pipeline: PipelineStage[] = [\r\n      {\r\n        $lookup: {\r\n          from: \"users\",\r\n          localField: \"userId\",\r\n          foreignField: \"_id\",\r\n          as: \"userId\",\r\n        },\r\n      },\r\n      {\r\n        $unwind: {\r\n          path: \"$userId\",\r\n          preserveNullAndEmptyArrays: true,\r\n        },\r\n      },\r\n\r\n      { $match: matchStage },\r\n\r\n      { $sort: { createdAt: -1 } },\r\n\r\n      {\r\n        $facet: {\r\n          reviews: [\r\n            { $skip: (page - 1) * limit },\r\n            { $limit: limit },\r\n            {\r\n              $project: {\r\n                _id: 1,\r\n                reviewId: 1,\r\n                rating: 1,\r\n                comment: 1,\r\n                isApproved: 1,\r\n                isSelect: 1,\r\n                createdAt: 1,\r\n                userId: 1,\r\n              },\r\n            },\r\n          ],\r\n          total: [{ $count: \"count\" }],\r\n        },\r\n      },\r\n    ];\r\n\r\n    const result = await this.model.aggregate(pipeline).exec();\r\n\r\n    const reviews = result[0]?.reviews || [];\r\n    const total = result[0]?.total[0]?.count || 0;\r\n\r\n    return {\r\n      reviews: reviews as unknown as IReview[],\r\n      total,\r\n      page,\r\n      pages: Math.ceil(total / limit),\r\n    };\r\n  } catch (error) {\r\n    logger.error(\"Error fetching paginated reviews\", error);\r\n    throw new RepositoryError(\r\n      \"Error fetching paginated reviews\",\r\n      StatusCodes.INTERNAL_SERVER_ERROR,\r\n      error as Error\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n  public updateReview = async (\r\n    reviewId: string,\r\n    updates: { isApproved?: boolean; isSelect?: boolean }\r\n  ): Promise<IReview | null> => {\r\n    try {\r\n      logger.debug(`Updating review: ${reviewId}`);\r\n      const review = await this.model\r\n        .findByIdAndUpdate(this.toObjectId(reviewId), updates, { new: true })\r\n        .populate('userId', '_id email name')\r\n        .exec();\r\n      if (!review) {\r\n        logger.warn(`Review not found: ${reviewId}`);\r\n        throw new RepositoryError(`Review not found with ID: ${reviewId}`, StatusCodes.NOT_FOUND);\r\n      }\r\n      logger.info(`Review updated: ${reviewId}`);\r\n      return review;\r\n    } catch (error: unknown) {\r\n      const err = error instanceof Error ? error : new Error(String(error));\r\n      logger.error(`Error updating review ${reviewId}`, err);\r\n      throw new RepositoryError('Error updating review', StatusCodes.INTERNAL_SERVER_ERROR, err);\r\n    }\r\n  }\r\n\r\n  public getSelectedReviews = async (): Promise<IReview[]> => {\r\n    try {\r\n      logger.debug('Fetching selected and approved reviews');\r\n      const reviews = await this.model\r\n        .find({ isSelect: true, isApproved: true })\r\n        .populate('userId', '_id email name')\r\n        .exec();\r\n      logger.info(`Fetched ${reviews.length} selected and approved reviews`);\r\n      return reviews;\r\n    } catch (error: unknown) {\r\n      const err = error instanceof Error ? error : new Error(String(error));\r\n      logger.error(`Error fetching selected reviews`, err);\r\n      throw new RepositoryError('Error fetching selected reviews', StatusCodes.INTERNAL_SERVER_ERROR, err);\r\n    }\r\n  }\r\n}"]}