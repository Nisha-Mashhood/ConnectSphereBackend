{"version":3,"file":"notification-controller.js","sourceRoot":"","sources":["../../src/controllers/notification-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { NextFunction, Request, Response } from \"express\";\r\nimport { inject, injectable } from \"inversify\";\r\nimport logger from \"../core/utils/logger\";\r\nimport { IAppNotification } from \"../Interfaces/Models/i-app-notification\";\r\nimport { INotificationController } from \"../Interfaces/Controller/i-notification-controller\";\r\nimport { StatusCodes } from \"../enums/status-code-enums\";\r\nimport { BaseController } from \"../core/controller/base-controller\";\r\nimport { HttpError } from \"../core/utils/error-handler\";\r\nimport { INotificationService } from \"../Interfaces/Services/i-notification-service\";\r\nimport { ERROR_MESSAGES } from \"../constants/error-messages\";\r\nimport { NOTIFICATION_MESSAGES } from \"../constants/messages\";\r\n\r\n@injectable()\r\nexport class NotificationController extends BaseController implements INotificationController{\r\n  private _notificationService: INotificationService;\r\n\r\n  constructor(@inject('INotificationService') notificationService : INotificationService) {\r\n    super();\r\n    this._notificationService = notificationService;\r\n  }\r\n\r\n  getNotifications = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\r\n    try {\r\n      const userId = req.query.userId as string;\r\n      logger.debug(`Fetching notifications for user: ${userId}`);\r\n\r\n      if (!userId) {\r\n        logger.error(\"Missing userId\");\r\n        throw new HttpError(ERROR_MESSAGES.REQUIRED_USER_ID, StatusCodes.BAD_REQUEST);\r\n      }\r\n\r\n      if (!req.currentUser || req.currentUser.role === \"admin\") {\r\n        logger.info(\r\n          `No notifications for ${\r\n            req.currentUser ? \"admin\" : \"unauthenticated user\"\r\n          }, userId: ${userId}`\r\n        );\r\n        this.sendSuccess(res, [], NOTIFICATION_MESSAGES.NO_NOTIFICATIONS_AVAILABLE);\r\n        return;\r\n      }\r\n\r\n      const notifications = await this._notificationService.getNotifications(userId);\r\n      this.sendSuccess(res, notifications, NOTIFICATION_MESSAGES.NOTIFICATIONS_FETCHED);\r\n    } catch (error: any) {\r\n      logger.error(`Error fetching notifications: ${error.message}`);\r\n      next(error);\r\n    }\r\n  };\r\n\r\n  markAsRead = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\r\n    try {\r\n      const notificationId = req.query.notificationId as string | undefined;\r\n      const userId = req.query.userId as string | undefined;\r\n      const type = req.query.type as IAppNotification[\"type\"] | undefined;\r\n\r\n      logger.info(`Notification Id ${notificationId} userId ${userId} type ${type}`);\r\n\r\n      if (type && (!req.currentUser || req.currentUser.role !== \"admin\")) {\r\n        logger.info(\r\n          `No action for ${\r\n            req.currentUser ? \"non-admin\" : \"unauthenticated user\"\r\n          } marking notifications by type: ${type}`\r\n        );\r\n        throw new HttpError(ERROR_MESSAGES.ONLY_ADMINS_CAN_MARK_BY_TYPE, StatusCodes.FORBIDDEN);\r\n      }\r\n\r\n      if (type && !userId) {\r\n        logger.error(\"userId is required when marking notifications by type\");\r\n        throw new HttpError(ERROR_MESSAGES.REQUIRED_USER_ID_FOR_TYPE, StatusCodes.BAD_REQUEST);\r\n      }\r\n\r\n      const result = await this._notificationService.markNotificationAsRead(notificationId, userId, type);\r\n\r\n      this.sendSuccess(\r\n        res,\r\n        result || [],\r\n        notificationId\r\n          ? NOTIFICATION_MESSAGES.NOTIFICATION_MARKED_AS_READ\r\n          : NOTIFICATION_MESSAGES.NOTIFICATIONS_MARKED_AS_READ\r\n      );\r\n    } catch (error: any) {\r\n      logger.error(`Error marking notification(s) as read: ${error.message}`);\r\n      next(error);\r\n    }\r\n  };\r\n\r\n  getUnreadCount = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\r\n    try {\r\n      const userId = req.query.userId as string;\r\n      const type = req.query.type as IAppNotification[\"type\"];\r\n      logger.debug(`Fetching unread notification count for user: ${userId}${type ? `, type: ${type}` : \"\"}`);\r\n\r\n      if (!userId) {\r\n        logger.error(\"Missing userId\");\r\n        throw new HttpError(ERROR_MESSAGES.REQUIRED_USER_ID, StatusCodes.BAD_REQUEST);\r\n      }\r\n\r\n      if (!req.currentUser) {\r\n        logger.info(`No unread count for unauthenticated user, userId: ${userId}`);\r\n        this.sendSuccess(res, { count: 0 }, NOTIFICATION_MESSAGES.NO_NOTIFICATIONS_AVAILABLE);\r\n        return;\r\n      }\r\n\r\n      const count = await this._notificationService.getUnreadCount(userId, type);\r\n      this.sendSuccess(res, { count }, NOTIFICATION_MESSAGES.UNREAD_COUNT_FETCHED);\r\n    } catch (error: any) {\r\n      logger.error(`Error fetching unread notification count: ${error.message}`);\r\n      next(error);\r\n    }\r\n  };\r\n}\r\n"]}