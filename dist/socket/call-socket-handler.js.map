{"version":3,"file":"call-socket-handler.js","sourceRoot":"","sources":["../../src/socket/call-socket-handler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Server, Socket } from \"socket.io\";\r\nimport logger from \"../core/utils/logger\";\r\nimport { CallData, CallOffer } from \"../Utils/types/socket-service-types\";\r\nimport { createCallLog, updateCallLog } from \"./Utils/call-log-helper\";\r\nimport { inject, injectable } from \"inversify\";\r\nimport { ICallSocketHandler } from \"../Interfaces/Services/i-call-socket-handler\";\r\nimport { IContactRepository } from \"../Interfaces/Repository/i-contact-repositry\";\r\nimport { IGroupRepository } from \"../Interfaces/Repository/i-group-repositry\";\r\nimport { IUserRepository } from \"../Interfaces/Repository/i-user-repositry\";\r\nimport { INotificationService } from \"../Interfaces/Services/i-notification-service\";\r\nimport { ICallLogRepository } from \"../Interfaces/Repository/i-call-repositry\";\r\nimport { CallCreatedEvent } from \"./types\";\r\n\r\n@injectable()\r\nexport class CallSocketHandler implements ICallSocketHandler{\r\n  private _activeOffers: Map<string, CallOffer> = new Map();\r\n  private _endedCalls: Set<string> = new Set();\r\n  private _contactsRepo: IContactRepository;\r\n  private _groupRepo: IGroupRepository;\r\n  private _userRepo: IUserRepository;\r\n  private _notificationService: INotificationService;\r\n  private _callLogRepo: ICallLogRepository;\r\n  private _io: Server | null = null;\r\n\r\n  constructor(\r\n    @inject(\"IContactRepository\") contactsRepo: IContactRepository,\r\n    @inject(\"IGroupRepository\") groupRepo: IGroupRepository,\r\n    @inject(\"IUserRepository\") userRepo: IUserRepository,\r\n    @inject(\"INotificationService\") notificationService: INotificationService,\r\n    @inject(\"ICallLogRepository\") callLogRepo: ICallLogRepository\r\n  ) {\r\n    this._contactsRepo = contactsRepo;\r\n    this._groupRepo = groupRepo;\r\n    this._userRepo = userRepo;\r\n    this._notificationService = notificationService;\r\n    this._callLogRepo = callLogRepo;\r\n    logger.debug(\r\n      `CallSocketHandler initialized with callLogRepo: ${!!callLogRepo}`\r\n    );\r\n    if (!callLogRepo) {\r\n      logger.error(\"CallLogRepository is not initialized\");\r\n      throw new Error(\"CallLogRepository is required\");\r\n    }\r\n  }\r\n\r\n  public setIo(io: Server): void {\r\n    this._io = io;\r\n  }\r\n\r\n  \r\npublic async handleOffer(socket: Socket, data: CallData): Promise<void> {\r\n  try {\r\n    const { userId, targetId, type, chatKey, offer, callType } = data;\r\n    logger.info(`Received ${callType} offer from ${userId} for chatKey: ${chatKey}`);\r\n\r\n    let room: string;\r\n    let recipientIds: string[] = [];\r\n    let contentType: \"group\" | \"collaboration\" | \"userconnection\";\r\n\r\n    if (type === \"group\") {\r\n      // group call path (we are not implementing full group flow yet, but keep logic consistent)\r\n      room = `group_${targetId}`;\r\n      contentType = \"group\";\r\n      const group = await this._groupRepo.getGroupById(targetId);\r\n      if (!group) {\r\n        logger.error(`Invalid group ID: ${targetId}`);\r\n        socket.emit(\"error\", { message: \"Invalid group ID\" });\r\n        return;\r\n      }\r\n      recipientIds = group.members\r\n        .filter((member) => member.userId.toString() !== userId)\r\n        .map((member) => member.userId.toString());\r\n    } else {\r\n      // one-on-one (user-user or user-mentor)\r\n      const contact = await this._contactsRepo.findContactByUsers(userId, targetId);\r\n      if (!contact) {\r\n        logger.error(`Invalid contact for offer: userId=${userId}, targetId=${targetId}`);\r\n        socket.emit(\"error\", { message: \"Invalid contact\" });\r\n        return;\r\n      }\r\n      const ids = [contact.userId.toString(), contact.targetUserId?.toString()].sort();\r\n      room = `chat_${ids[0]}_${ids[1]}`;\r\n      recipientIds = [targetId];\r\n      contentType = contact.type === \"user-mentor\" ? \"collaboration\" : \"userconnection\";\r\n    }\r\n\r\n    const callId = `${chatKey}_${Date.now()}`;\r\n    // Broadcast the offer to the room (recipient(s) will receive it)\r\n    socket.broadcast.to(room).emit(\"offer\", {\r\n      userId,\r\n      targetId,\r\n      type,\r\n      chatKey,\r\n      offer,\r\n      callType,\r\n      callId,\r\n      senderName: (await this._userRepo.findById(userId))?.name || \"Unknown\",\r\n    });\r\n\r\n    // Create server-side callId and call log\r\n    const sender = await this._userRepo.findById(userId);\r\n    const callLog = await createCallLog(socket, this._io, this._callLogRepo, {\r\n      CallId: callId,\r\n      chatKey,\r\n      callType,\r\n      type,\r\n      senderId: userId,\r\n      recipientIds,\r\n      groupId: type === \"group\" ? targetId : undefined,\r\n      callerName: sender?.name || \"Unknown\",\r\n    });\r\n\r\n    if (!callLog) {\r\n      logger.error(`Failed to create call log for callId: ${callId}`);\r\n      socket.emit(\"error\", { message: \"Failed to create call record\" });\r\n      return;\r\n    }\r\n\r\n    // Notify the offerer (the socket that sent the offer) with server-generated callId and metadata\r\n    const createdEvent: CallCreatedEvent = {\r\n      callId,\r\n      chatKey,\r\n      callType,\r\n      type,\r\n      senderId: userId,\r\n      recipientIds,\r\n      groupId: type === \"group\" ? targetId : undefined,\r\n      callerName: sender?.name || \"Unknown\",\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n\r\n    socket.emit(\"call.created\", createdEvent);\r\n    logger.info(`Emitted call.created to offerer ${userId} with callId ${callId}`);\r\n\r\n    // send incoming call notifications for each recipient (non-blocking)\r\n    for (const recipientId of recipientIds) {\r\n      try {\r\n        const notification = await this._notificationService.sendNotification(\r\n          recipientId,\r\n          \"incoming_call\",\r\n          userId,\r\n          chatKey,\r\n          contentType,\r\n          callId,\r\n          callType,\r\n          `incoming ${callType} call from ${sender?.name || \"Unknown\"}`\r\n        );\r\n\r\n        if (notification && this._io) {\r\n          // if the recipient is connected, notify them directly\r\n          this._io.to(`user_${recipientId}`).emit(\"notification.new\", notification);\r\n        }\r\n\r\n        logger.info(`Created call notification for user ${recipientId}: ${notification?.id}`);\r\n      } catch (err) {\r\n        logger.warn(`Failed to send call notification to user ${recipientId}: ${(err as Error).message}`);\r\n      }\r\n    }\r\n\r\n    // create end-timeout for unanswered call (30s)\r\n    const endTimeout = setTimeout(async () => {\r\n      const call = this._activeOffers.get(callId);\r\n      if (!call) return;\r\n\r\n      // find sockets currently connected in the room to determine who answered\r\n      const socketsInRoom = await this._io?.in(room).allSockets();\r\n      const connectedUserIds = new Set<string>();\r\n      if (socketsInRoom) {\r\n        for (const socketId of socketsInRoom) {\r\n          const s = this._io?.sockets.sockets.get(socketId);\r\n          if (s && s.data.userId) {\r\n            connectedUserIds.add(s.data.userId);\r\n          }\r\n        }\r\n      }\r\n\r\n      // for each recipient, if they never connected, mark call as missed for that recipient\r\n      for (const recipientId of recipientIds) {\r\n        if (!connectedUserIds.has(recipientId)) {\r\n          const updatedCallLog = await updateCallLog(\r\n            socket,\r\n            this._io,\r\n            this._callLogRepo,\r\n            callId,\r\n            userId,\r\n            recipientIds,\r\n            {\r\n              status: \"missed\",\r\n              endTime: new Date(),\r\n            }\r\n          );\r\n\r\n          if (!updatedCallLog) {\r\n            logger.error(`Failed to update call log to missed for CallId: ${callId}`);\r\n            continue;\r\n          }\r\n\r\n          // update notification to missed or create missed notification\r\n          const notification = await this._notificationService.updateCallNotificationToMissed(\r\n            recipientId,\r\n            callId,\r\n            `Missed ${callType} call from ${userId}`\r\n          );\r\n\r\n          if (notification && this._io) {\r\n            this._io.to(`user_${recipientId}`).emit(\"notification.updated\", notification);\r\n          } else {\r\n            // fallback: create missed notification\r\n            const newNotification = await this._notificationService.sendNotification(\r\n              recipientId,\r\n              \"missed_call\",\r\n              userId,\r\n              chatKey,\r\n              contentType,\r\n              callId,\r\n              callType,\r\n              `Missed ${callType} call from ${sender?.name || \"Unknown\"}`\r\n            );\r\n            if (this._io && newNotification) {\r\n              this._io.to(`user_${recipientId}`).emit(\"notification.new\", newNotification);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // inform all sockets in the room that call ended (missed)\r\n      socket.to(room).emit(\"callEnded\", { userId, targetId, type, chatKey, callType, callId, reason: \"missed\" });\r\n      socket.emit(\"callEnded\", { userId, targetId, type, chatKey, callType, callId, reason: \"missed\" });\r\n\r\n      // cleanup\r\n      this._activeOffers.delete(callId);\r\n      logger.info(`Call ${callId} marked missed and cleaned up after timeout`);\r\n    }, 30000);\r\n\r\n    // store active offer with endTimeout\r\n    const callOffer: CallOffer = {\r\n      senderId: userId,\r\n      targetId,\r\n      type,\r\n      chatKey,\r\n      callType,\r\n      recipientIds,\r\n      endTimeout,\r\n    };\r\n\r\n    this._activeOffers.set(callId, callOffer);\r\n    logger.info(`Stored active offer for callId ${callId}`);\r\n  } catch (error) {\r\n    logger.error(`Error broadcasting offer: ${(error as Error).message}`);\r\n    socket.emit(\"error\", { message: \"Failed to send offer\" });\r\n  }\r\n}\r\n\r\n  public async handleAnswer(socket: Socket, data: CallData): Promise<void> {\r\n    try {\r\n      const { userId, targetId, type, chatKey, answer, callType } = data;\r\n      logger.info(\r\n        `Received ${callType} answer from ${userId} for chatKey: ${chatKey}`\r\n      );\r\n      let room: string;\r\n\r\n      if (type === \"group\") {\r\n        room = `group_${targetId}`;\r\n      } else {\r\n        const contact = await this._contactsRepo.findContactByUsers(\r\n          userId,\r\n          targetId\r\n        );\r\n        if (!contact) {\r\n          logger.error(\r\n            `Invalid contact for answer: userId=${userId}, targetId=${targetId}`\r\n          );\r\n          socket.emit(\"error\", { message: \"Invalid contact\" });\r\n          return;\r\n        }\r\n        const ids = [\r\n          contact.userId.toString(),\r\n          contact.targetUserId?.toString(),\r\n        ].sort();\r\n        room = `chat_${ids[0]}_${ids[1]}`;\r\n      }\r\n\r\n      socket.broadcast\r\n        .to(room)\r\n        .emit(\"answer\", { userId, targetId, type, chatKey, answer, callType });\r\n\r\n      const callId = Array.from(this._activeOffers.keys()).find(\r\n        (id) =>\r\n          this._activeOffers.get(id)?.chatKey === chatKey &&\r\n          this._activeOffers.get(id)?.senderId === targetId\r\n      );\r\n      if (callId) {\r\n        const call = this._activeOffers.get(callId);\r\n        if (call) {\r\n          clearTimeout(call.endTimeout);\r\n          this._activeOffers.delete(callId);\r\n        }\r\n      }\r\n    } catch (error: any) {\r\n      logger.error(`Error broadcasting answer: ${error.message}`);\r\n      socket.emit(\"error\", { message: \"Failed to send answer\" });\r\n    }\r\n  }\r\n\r\n  public async handleIceCandidate(\r\n    socket: Socket,\r\n    data: CallData\r\n  ): Promise<void> {\r\n    try {\r\n      const { userId, targetId, type, chatKey, candidate, callType } = data;\r\n      logger.info(\r\n        `Received ${callType} ICE candidate from ${userId} for chatKey: ${chatKey}`\r\n      );\r\n      let room: string;\r\n\r\n      if (type === \"group\") {\r\n        room = `group_${targetId}`;\r\n      } else {\r\n        const contact = await this._contactsRepo.findContactByUsers(\r\n          userId,\r\n          targetId\r\n        );\r\n        if (!contact) {\r\n          logger.error(\r\n            `Invalid contact for ICE candidate: userId=${userId}, targetId=${targetId}`\r\n          );\r\n          socket.emit(\"error\", { message: \"Invalid contact\" });\r\n          return;\r\n        }\r\n        const ids = [\r\n          contact.userId.toString(),\r\n          contact.targetUserId?.toString(),\r\n        ].sort();\r\n        room = `chat_${ids[0]}_${ids[1]}`;\r\n      }\r\n\r\n      socket.broadcast.to(room).emit(\"ice-candidate\", {\r\n        userId,\r\n        targetId,\r\n        type,\r\n        chatKey,\r\n        candidate,\r\n        callType,\r\n      });\r\n    } catch (error: any) {\r\n      logger.error(`Error broadcasting ICE candidate: ${error.message}`);\r\n      socket.emit(\"error\", { message: \"Failed to send ICE candidate\" });\r\n    }\r\n  }\r\n\r\n  public async handleCallEnded(socket: Socket, data: CallData): Promise<void> {\r\n    try {\r\n      const { userId, targetId, type, chatKey, callType } = data;\r\n      const callId = Array.from(this._activeOffers.keys()).find(\r\n        (id) =>\r\n          this._activeOffers.get(id)?.chatKey === chatKey &&\r\n          this._activeOffers.get(id)?.senderId === userId\r\n      );\r\n      if (!callId || this._endedCalls.has(callId)) {\r\n        logger.info(\r\n          `Ignoring duplicate or invalid callEnded for callId: ${callId}, chatKey: ${chatKey}`\r\n        );\r\n        return;\r\n      }\r\n      logger.info(\r\n        `Received callEnded from ${userId} for chatKey: ${chatKey}, callType: ${callType}`\r\n      );\r\n\r\n      let room: string;\r\n      let recipientIds: string[] = [];\r\n      if (type === \"group\") {\r\n        room = `group_${targetId}`;\r\n        const group = await this._groupRepo.getGroupById(targetId);\r\n        if (!group) {\r\n          logger.error(`Invalid group ID: ${targetId}`);\r\n          socket.emit(\"error\", { message: \"Invalid group ID\" });\r\n          return;\r\n        }\r\n        recipientIds = group.members\r\n          .filter((member) => member.userId.toString() !== userId)\r\n          .map((member) => member.userId.toString());\r\n      } else {\r\n        const contact = await this._contactsRepo.findContactByUsers(\r\n          userId,\r\n          targetId\r\n        );\r\n        if (!contact) {\r\n          logger.error(\r\n            `Invalid contact for callEnded: userId=${userId}, targetId=${targetId}`\r\n          );\r\n          socket.emit(\"error\", { message: \"Invalid contact\" });\r\n          return;\r\n        }\r\n        const ids = [\r\n          contact.userId.toString(),\r\n          contact.targetUserId?.toString(),\r\n        ].sort();\r\n        room = `chat_${ids[0]}_${ids[1]}`;\r\n        recipientIds = [targetId];\r\n      }\r\n\r\n      // Update call log\r\n      const updatedCallLog = await updateCallLog(\r\n        socket,\r\n        this._io,\r\n        this._callLogRepo,\r\n        callId,\r\n        userId,\r\n        recipientIds,\r\n        {\r\n          status: \"completed\",\r\n          endTime: new Date(),\r\n        }\r\n      );\r\n\r\n      if (!updatedCallLog) {\r\n        logger.error(\r\n          `Failed to update call log to completed for CallId: ${callId}`\r\n        );\r\n        return;\r\n      }\r\n      this._io\r\n        ?.to(room)\r\n        .emit(\"callEnded\", { userId, targetId, type, chatKey, callType });\r\n      this._endedCalls.add(callId);\r\n      setTimeout(() => this._endedCalls.delete(callId), 60000);\r\n\r\n      const call = this._activeOffers.get(callId);\r\n      if (call) {\r\n        clearTimeout(call.endTimeout);\r\n        this._activeOffers.delete(callId);\r\n      }\r\n    } catch (error: any) {\r\n      logger.error(`Error handling callEnded: ${error.message}`);\r\n      socket.emit(\"error\", { message: \"Failed to end call\" });\r\n    }\r\n  }\r\n}\r\n"]}